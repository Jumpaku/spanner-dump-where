// Code generated by cyamli, DO NOT EDIT.
package main

import (
	"fmt"
	"strconv"
	"strings"
)

type CLIHandler interface {
	Run(input Input) error
}

func Run(handler CLIHandler, args []string) error {
	subcommandPath, options, arguments := resolveArgs(args)
	switch strings.Join(subcommandPath, " ") {
	case "":
		var input Input
		input.resolveInput(subcommandPath, options, arguments)
		return handler.Run(input)
	}
	return nil
}

type Input struct {
	Opt_BulkSize  int64
	Opt_Database  string
	Opt_From      []string
	Opt_Instance  string
	Opt_NoData    bool
	Opt_NoDdl     bool
	Opt_Project   string
	Opt_Sort      bool
	Opt_Timestamp string
	Opt_Upsert    bool
	Opt_Where     []string
	Subcommand    []string
	Options       []string
	Arguments     []string

	ErrorMessage string
}

func (input *Input) resolveInput(subcommand, options, arguments []string) {
	*input = Input{Opt_BulkSize: 100,
		Opt_Database:  "",
		Opt_From:      []string{},
		Opt_Instance:  "",
		Opt_NoData:    false,
		Opt_NoDdl:     false,
		Opt_Project:   "",
		Opt_Sort:      false,
		Opt_Timestamp: "",
		Opt_Upsert:    false,
		Opt_Where:     []string{},
		Subcommand:    subcommand,
		Options:       options,
		Arguments:     arguments,
	}

	for _, arg := range input.Options {
		optName, lit, cut := strings.Cut(arg, "=")
		func(...any) {}(optName, lit, cut)

		switch optName {
		case "-bulk-size":
			if !cut {
				input.ErrorMessage = fmt.Sprintf("value is not specified to option %q", optName)
				return
			}
			if v, err := parseValue("int64", lit); err != nil {
				input.ErrorMessage = fmt.Sprintf("value %q is not assignable to option %q", lit, optName)
				return
			} else {
				input.Opt_BulkSize = v.(int64)
			}

		case "-database", "-d":
			if !cut {
				input.ErrorMessage = fmt.Sprintf("value is not specified to option %q", optName)
				return
			}
			if v, err := parseValue("string", lit); err != nil {
				input.ErrorMessage = fmt.Sprintf("value %q is not assignable to option %q", lit, optName)
				return
			} else {
				input.Opt_Database = v.(string)
			}

		case "-from":
			if !cut {
				input.ErrorMessage = fmt.Sprintf("value is not specified to option %q", optName)
				return
			}
			if v, err := parseValue("[]string", lit); err != nil {
				input.ErrorMessage = fmt.Sprintf("value %q is not assignable to option %q", lit, optName)
				return
			} else {
				input.Opt_From = append(input.Opt_From, v.([]string)[0])
			}

		case "-instance", "-i":
			if !cut {
				input.ErrorMessage = fmt.Sprintf("value is not specified to option %q", optName)
				return
			}
			if v, err := parseValue("string", lit); err != nil {
				input.ErrorMessage = fmt.Sprintf("value %q is not assignable to option %q", lit, optName)
				return
			} else {
				input.Opt_Instance = v.(string)
			}

		case "-no-data":
			if !cut {
				lit = "true"
			}
			if v, err := parseValue("bool", lit); err != nil {
				input.ErrorMessage = fmt.Sprintf("value %q is not assignable to option %q", lit, optName)
				return
			} else {
				input.Opt_NoData = v.(bool)
			}

		case "-no-ddl":
			if !cut {
				lit = "true"
			}
			if v, err := parseValue("bool", lit); err != nil {
				input.ErrorMessage = fmt.Sprintf("value %q is not assignable to option %q", lit, optName)
				return
			} else {
				input.Opt_NoDdl = v.(bool)
			}

		case "-project", "-p":
			if !cut {
				input.ErrorMessage = fmt.Sprintf("value is not specified to option %q", optName)
				return
			}
			if v, err := parseValue("string", lit); err != nil {
				input.ErrorMessage = fmt.Sprintf("value %q is not assignable to option %q", lit, optName)
				return
			} else {
				input.Opt_Project = v.(string)
			}

		case "-sort":
			if !cut {
				lit = "true"
			}
			if v, err := parseValue("bool", lit); err != nil {
				input.ErrorMessage = fmt.Sprintf("value %q is not assignable to option %q", lit, optName)
				return
			} else {
				input.Opt_Sort = v.(bool)
			}

		case "-timestamp", "-t":
			if !cut {
				input.ErrorMessage = fmt.Sprintf("value is not specified to option %q", optName)
				return
			}
			if v, err := parseValue("string", lit); err != nil {
				input.ErrorMessage = fmt.Sprintf("value %q is not assignable to option %q", lit, optName)
				return
			} else {
				input.Opt_Timestamp = v.(string)
			}

		case "-upsert":
			if !cut {
				lit = "true"
			}
			if v, err := parseValue("bool", lit); err != nil {
				input.ErrorMessage = fmt.Sprintf("value %q is not assignable to option %q", lit, optName)
				return
			} else {
				input.Opt_Upsert = v.(bool)
			}

		case "-where":
			if !cut {
				input.ErrorMessage = fmt.Sprintf("value is not specified to option %q", optName)
				return
			}
			if v, err := parseValue("[]string", lit); err != nil {
				input.ErrorMessage = fmt.Sprintf("value %q is not assignable to option %q", lit, optName)
				return
			} else {
				input.Opt_Where = append(input.Opt_Where, v.([]string)[0])
			}

		default:
			input.ErrorMessage = fmt.Sprintf("unknown option %q", optName)
			return
		}
	}

	expectedArgs := 0
	func(...any) {}(expectedArgs)
}
func resolveArgs(args []string) (subcommandPath []string, options []string, arguments []string) {
	if len(args) == 0 {
		panic("command line arguments are too few")
	}
	subcommandSet := map[string]bool{
		"": true,
	}

	for _, arg := range args[1:] {
		if arg == "--" {
			break
		}
		pathLiteral := strings.Join(append(append([]string{}, subcommandPath...), arg), " ")
		if !subcommandSet[pathLiteral] {
			break
		}
		subcommandPath = append(subcommandPath, arg)
	}

	restArgs := args[1+len(subcommandPath):]
	for idx, arg := range restArgs {
		if arg == "--" {
			arguments = append(arguments, restArgs[idx+1:]...)
			break
		}
		if strings.HasPrefix(arg, "-") {
			options = append(options, arg)
		} else {
			arguments = append(arguments, arg)
		}
	}

	return subcommandPath, options, arguments
}

func parseValue(typ string, strValue ...string) (dst any, err error) {
	switch typ {
	case "[]bool":
		val := make([]bool, len(strValue))
		for idx, str := range strValue {
			var v any
			if v, err = parseValue("bool", str); err != nil {
				return nil, fmt.Errorf("fail to parse %#v as []bool: %w", str, err)
			}
			val[idx] = v.(bool)
		}
		return val, nil
	case "[]int64":
		val := make([]int64, len(strValue))
		for idx, str := range strValue {
			var v any
			if v, err = parseValue("int64", str); err != nil {
				return nil, fmt.Errorf("fail to parse %#v as []int64: %w", str, err)
			}
			val[idx] = v.(int64)
		}
		return val, nil
	case "[]string":
		val := make([]string, len(strValue))
		for idx, str := range strValue {
			var v any
			if v, err = parseValue("string", str); err != nil {
				return nil, fmt.Errorf("fail to parse %#v as []string: %w", str, err)
			}
			val[idx] = v.(string)
		}
		return val, nil
	case "bool":
		switch strings.ToLower(strValue[0]) {
		default:
			return nil, fmt.Errorf("fail to parse %q as bool: unknown value", strValue[0])
		case "true", "1", "t":
			return true, nil
		case "false", "0", "f":
			return false, nil
		}
	case "int64":
		val, err := strconv.ParseInt(strValue[0], 0, 64)
		if err != nil {
			return nil, fmt.Errorf("fail to parse %q as int64: %w", strValue[0], err)
		}
		return val, nil
	case "string":
		return strValue[0], nil
	}

	return nil, fmt.Errorf("unknown type %q", typ)
}

func GetVersion() string {
	return "v0.0.0"
}
func GetProgram() string {
	return "spanner-dump-where"
}
func GetDoc(subcommands []string) string {
	switch strings.Join(subcommands, " ") {
	case "":
		return "spanner-dump-where \n\n    Description:\n        Dump data from a Google Cloud Spanner database with specified conditions.\n        This command allows you to export data from a Spanner database, applying filters and options to control the output.\n\n    Syntax:\n        $ spanner-dump-where  [<option>]...\n\n    Options:\n        -bulk-size=<integer>  (default=100):\n            Number of rows to dump in a single batch.\n            This option is used to control the size of the data dump.\n\n        -database=<string>, -d=<string>  (default=\"\"):\n            Google Cloud Spanner database ID.\n            This option is required.\n\n        -from=<string>  (default=\"\"):\n            Table name to dump data from.\n            This option can be specified one or more times.\n\n        -instance=<string>, -i=<string>  (default=\"\"):\n            Google Cloud Spanner instance ID.\n            This option is required.\n\n        -no-data[=<boolean>]  (default=false):\n            If true, do not dump data.\n\n        -no-ddl[=<boolean>]  (default=false):\n            If true, do not dump DDL statements.\n\n        -project=<string>, -p=<string>  (default=\"\"):\n            Google Cloud project ID.\n            This option is required.\n\n        -sort[=<boolean>]  (default=false):\n            If true, sort the dump order according to dependency relationships on tables.\n            This option is used to control the order of the dumped data.\n\n        -timestamp=<string>, -t=<string>  (default=\"\"):\n            Timestamp to use for the dump.\n\n        -upsert[=<boolean>]  (default=false):\n            If true, use INSERT OR UPDATE instead of INSERT.\n\n        -where=<string>  (default=\"\"):\n            Condition to filter data.\n            This option is required for each -from option.\n            The format is an SQL boolean expression after WHERE clause.\n\n\n"
	default:
		panic(fmt.Sprintf(`invalid subcommands: %v`, subcommands))
	}
}
